/*
  This file is part of p4est.
  p4est is a C library to manage a collection (a forest) of multiple
  connected adaptive quadtrees or octrees in parallel.

  Copyright (C) 2010 The University of Texas System
  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac

  p4est is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  p4est is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with p4est; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*/

/** \page connectivity The connectivity structure
 *
 * An overview of p4est's connectivity structure.
 *
 * ## The basic idea and definition
 * p4est leverages structured octree grids for efficient highly-scalable
 * adaptive mesh refinement (AMR). At the same time p4est enables the user to
 * represent a general and possibly non-squared (2D), non-cubic (3D) domain.
 * This flexibility for the domain choice is achieved by using a forest of
 * quadtrees (2D) or octrees (3D) instead of a single tree.
 * The forest represents a coarse mesh topology where each tree
 * is a logical hypercube. To represent a general domain, we cover
 * the domain with a conforming mesh of (potentially mapped) squares (2D) or
 * cubes (3D). Each square (2D) or cube (3D) represents a quadtree (2D) or
 * octree (3D) root. These trees are connected with respect to their root's
 * topological entities, i.e. in 2D corners and faces and in 3D corner, faces
 * and edges. This coarest possible is defined as the connectivity of a forest.
 * It can not be changed during a simulation and in particular it can not be
 * coarsended further.
 *
 * ## Guidelines for connectivity design
 * Since the connectivity can not be changed during a simulation it should be
 * designed carefully. A few guidelines (replace cube(s) by square(s) for 2D)
 * are:
 * 1. Use as many cubes as needed to capture the domain's topology (connected
 *    components, holes, tunnels, etc.).
 * 2. Invest some more cubes to achieve an ideally uniform individual aspect
 *    ratio of each cube.
 * 3. Invest some more cubes if the distortion in any single mapped octree
 *    appears too large.
 * 4. Reduce the number of trees if the coarse mesh must be limited for
 *    numerical reasons.
 *
 * We have successfully connected millions of trees. Below 100k, there is no
 * need to even think about reducing their number if the procedure would not be
 * obvious.
 *
 * ## Constructing the connectivity
 * The easiest way to create a connectivity is to use a
 * predefined function in \ref p4est_connectivity.h (2D) or \ref
 * p8est_connectivity.h (3D). These predefined functions
 * `p4est_connectivity_new_*` (2D) and `p8est_connectivity_new_*` (3D) implement
 * some basic connectivities like a unit square (\ref
 * p4est_connectivity_new_unitsquare) or a unit cube (\ref
 * p8est_connectivity_new_unitcube) but also more advanced connectivities like a
 * icosahedron (\ref p4est_connectivity_new_icosahedron) or a 3D torus (\ref
 * p8est_connectivity_new_torus).
 *
 * Moreover, we want to point to the possibility of connecting topological
 * entities inside a single tree. This means that one can create periodic
 * connectivities, e.g. \ref p4est_connectivity_new_periodic (2D) and \ref
 * p8est_connectivity_new_periodic (3D).
 *
 * We also offer the functions \ref p4est_connectivity_read_inp (2D) and \ref
 * p8est_connectivity_read_inp (3D) to read a connectivity from an Abaqus
 * `.inp` file.
 *
 * The user can also create a new connectivity by allocating and populating
 * the connectivity structure using \ref p4est_connectivity_new_copy (2D) or
 * \ref p8est_connectivity_new_copy (3D). See the next section and \ref
 * p4est_connectivity_t (2D) or \ref p8est_connectivity_t (3D) for more
 * information on the elements of the connectivity structure.
 *
 * ## The connectivity data structure
 * The connectivity data structure (cf. \ref p4est_connectivity_t (2D), \ref
 * p8est_connectivity_t (3D)) is a public struct with documented entries and it is
 * independent of the MPI rank and hence must be the same on all MPI ranks.
 *
 * You may build any numbers of forests with the same connectivity object, but
 * the connectivity object must be destroyed only after the last of the forests
 * has been freed and the connectivity object must definitely be destroyed
 * (\ref p4est_connectivity_destroy (2D), \ref p8est_connectivity_destroy (3D)).
 *
 * ### Elements of the connectivity
 * The connectivity data structure consists of arrays and counts of different
 * entities. In particular, the connectivity data structure contains the number
 * of trees [num_trees](\ref p4est_connectivity_t::num_trees) and the number of
 * vertices [num_vertices](\ref p4est_connectivity_t::num_vertices). The
 * vertices are stored in the double array
 * [vertices](\ref p4est_connectivity_t::num_vertices). It is important to note
 * that the vertices are always points in \f$R^3\f$; even in the
 * [2D connectivity](\ref p4est_connectivity_t). These vertices are used to
 * embed each tree into \f$R^3\f$ in the array
 * [tree_to_vertex](\ref p4est_connectivity_t::tree_to_vertex). The embedding
 * into \f$R^3\f$ is for example used for visualization (cf. \ref
 * p4est_vtk.h (2D), \ref p8est_vtk.h (3D)) or a custom
 * transformation from tree-local coordinates to a user-defined physical space
 * (cf. \ref p4est_geometry_new_connectivity (2D), \ref
 * p8est_geometry_new_connectivity (3D)). Then arrays like
 * [tree_to_tree](\ref p4est_connectivity_t::tree_to_tree) and
 * [tree_to_face](\ref p4est_connectivity_t::tree_to_face) encode the inter-tree
 * connectivity information. For more information of the encoding in these
 * arrays and the other arrays see the documentation of \ref
 * p4est_connectivity_t (2D) and \ref p8est_connectivity_t (3D) and the
 * documentation of the respective elements of the two structures.
 *
 * TODO: z order, destroy.
 */
